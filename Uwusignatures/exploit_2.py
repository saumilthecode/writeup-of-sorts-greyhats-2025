
import socket
import json
import hashlib
from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse, GCD

HOST = "challs.nusgreyhats.org"   # or can use "challs2.nusgreyhats.org"
PORT = 33301

def sha256_to_int(m_int: int) -> int:
    """
    Hashes the integer m_int via SHA-256 of its byte‐representation,
    returning the digest as a big integer.
    """
    h = hashlib.sha256()
    h.update(long_to_bytes(m_int))
    return bytes_to_long(h.digest())

def recv_line(sock: socket.socket) -> bytes:
    """
    Read until and including a newline (b'\n'). Returns the full line.
    """
    buf = b""
    while True:
        c = sock.recv(1)
        if not c:
            raise RuntimeError("Connection closed while waiting for newline")
        buf += c
        if c == b'\n':
            return buf

def recv_until(sock: socket.socket, ending: bytes) -> bytes:
    """
    Read one byte at a time until the buffer ends with `ending`.
    Returns the entire buffer (including that ending).
    """
    buf = b""
    while not buf.endswith(ending):
        c = sock.recv(1)
        if not c:
            raise RuntimeError(f"Connection closed while waiting for {ending!r}")
        buf += c
    return buf

def solve_for_x(r: int, rhs: int, mod: int, g: int, p: int, y: int) -> int:
    """
    Solve r·x ≡ rhs (mod mod), where mod = p−1.  If gcd(r,mod)=d > 1,
    there are d solutions modulo mod, spaced by mod/d.  We return
    the unique x in [0, p−1] satisfying g^x ≡ y (mod p).

    - r:             g^k mod p
    - rhs:           (h1 − s1·k) mod (p−1)
    - mod:           p−1
    - g, p, y:       public key data, used to disambiguate candidates
    """
    d = GCD(r, mod)
    # Check that d divides rhs:
    if rhs % d != 0:
        raise ValueError(f"No solution: gcd(r,mod)={d} does not divide rhs={rhs}")

    # Reduce the congruence: (r/d) · x ≡ (rhs/d)  (mod mod/d)
    r_reduced   = r // d
    rhs_reduced = rhs // d
    mod_reduced = mod // d

    # Compute inverse(r_reduced, mod_reduced).  It must exist since gcd(r_reduced, mod_reduced)=1
    inv_r_red = inverse(r_reduced, mod_reduced)

    # One base solution in [0, mod_reduced−1]:
    x0 = (rhs_reduced * inv_r_red) % mod_reduced

    # All solutions modulo mod are: x0 + i·(mod/d)  for i=0..d−1
    for i in range(d):
        candidate = x0 + i * mod_reduced
        # We know the real x satisfies g^x ≡ y  (mod p).  Test it:
        if pow(g, candidate, p) == y:
            return candidate

    raise RuntimeError("No candidate in [0,mod) matched g^x ≡ y.  Something’s wrong.")

def main():
    # 1) Connect to the server
    sock = socket.create_connection((HOST, PORT))
    # We’ll use raw recv/sendplus a file‐like handle for JSON writes.
    f = sock.makefile("rw", buffering=1, newline="\n")

    #
    # 2) Read and parse the initial lines:
    #    (a) Welcome banner (ignore)
    #    (b) "<p> <g> <y>"
    #    (c) "k: <k>"
    #
    _ = recv_line(sock)  # e.g. b"Welcome to my super uwu secure digital signature scheme!\n"

    line1 = recv_line(sock).strip().decode()
    # Format: "<p> <g> <y>"
    p_str, g_str, y_str = line1.split()
    p = int(p_str)
    g = int(g_str)
    y = int(y_str)

    line2 = recv_line(sock).strip().decode()
    # Format: "k: <k>"
    assert line2.startswith("k:")
    k = int(line2.split()[1])

    print(f"[*] Read parameters:\n"
          f"    p = {p}\n"
          f"    g = {g}\n"
          f"    y = {y}\n"
          f"    k (leaked) = {k}")

    # 3) Compute r = g^k mod p
    r = pow(g, k, p)
    print(f"[*] Computed r = g^k mod p = {r}")

    #
    # 4) Menu #1: ask for one signature on an allowed message (choice = 2)
    #
    #    The server prints:
    #      "1. Show me some of your cutesy patootie signatures!\n"
    #      "2. Get some of my uwu signatures (max 2)\n"
    #      "> "   (no newline)
    #
    recv_line(sock)             # "1. Show me some of your …\n"
    recv_line(sock)             # "2. Get some of my uwu …\n"
    _ = recv_until(sock, b"> ") # prompt "> "

    # Send "2\n" to get a signature
    f.write("2\n")
    f.flush()

    # 5) The server prints "Send me a message: " (no newline), then waits for JSON.
    recv_until(sock, b"Send me a message: ")

    # Pick an arbitrary m1 ≠ forbidden.  Use m1 = 42.
    m1 = 42
    h1 = sha256_to_int(m1)

    # Send JSON: {"m": 42}\n
    to_send = json.dumps({"m": m1}) + "\n"
    f.write(to_send)
    f.flush()

    # 6) Server responds "Here's your uwu signature! <s1>\n"
    reply = recv_line(sock).strip().decode()
    # Format: "Here's your uwu signature! <s1>"
    s1 = int(reply.split()[-1])
    print(f"[*] Server returned signature s1 = {s1}")

    #
    # 7) Recover the private key x by solving:
    #        s1 ≡ (h1 − x·r) * inv(k, p−1)   (mod p−1)
    #    ⇒  (h1 − x·r) ≡ s1·k   (mod p−1)
    #    ⇒  r·x ≡ (h1 − s1·k)  (mod p−1)
    #
    PHI = p - 1
    rhs = (h1 - (s1 * k) % PHI) % PHI

    # Solve r·x ≡ rhs  (mod PHI), then verify g^x ≡ y to pick the correct root.
    x = solve_for_x(r, rhs, PHI, g, p, y)
    print(f"[*] Recovered private key x = {x}")

    #
    # 8) Forge a signature on the forbidden message:
    #    m_flag = bytes_to_long(b"gib flag pls uwu")
    #
    m_flag = bytes_to_long(b"gib flag pls uwu")
    h_flag = sha256_to_int(m_flag)

    # Re‐use the same k (hence the same r).  Then:
    #   s_flag ≡ (h_flag − x·r) * inv(k, p−1)   (mod p−1).
    inv_k = inverse(k, PHI)
    s_flag = ((h_flag - (x * r) % PHI) * inv_k) % PHI

    #
    # 9) Menu #2: submit our forged signature under choice = 1
    #
    #    Again the server prints the same two menu lines + "> ".
    recv_line(sock)             # "1. Show me some of your …\n"
    recv_line(sock)             # "2. Get some of my uwu …\n"
    _ = recv_until(sock, b"> ") # prompt "> "

    f.write("1\n")
    f.flush()

    # 10) Server prints "Send me a message and a signature: " (no newline),
    #     then waits for JSON.
    recv_until(sock, b"Send me a message and a signature: ")

    # Send JSON: {"m": m_flag, "r": r, "s": s_flag}\n
    payload2 = json.dumps({"m": m_flag, "r": r, "s": s_flag}) + "\n"
    f.write(payload2)
    f.flush()

    # 11) If successful, server prints:
    #      "Very cutesy, very mindful, very demure!\n"
    #       "<FLAG>\n"
    out1 = recv_line(sock).decode().strip()
    if out1.startswith("Very cutesy, very mindful, very demure!"):
        flag_line = recv_line(sock).decode().strip()
        print(f"\n\n>>> FLAG = {flag_line}")
    else:
        print("[-] Unexpected response at final step:")
        print(out1)
        for _ in range(3):
            try:
                print(recv_line(sock).decode().strip())
            except:
                break

    sock.close()


if __name__ == "__main__":
    main()
